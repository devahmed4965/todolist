import React, { useState, useEffect, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from 'firebase/auth';
import { getFirestore, collection, addDoc, doc, setDoc, deleteDoc, onSnapshot, query, Timestamp, serverTimestamp, setLogLevel } from 'firebase/firestore';
import { PlusCircle, Trash2, Zap, Edit3, Save, X, Bot, Sparkles, Loader2 } from 'lucide-react';

// --- Firebase Configuration ---
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
  apiKey: "YOUR_API_KEY", // Replace with your actual config
  authDomain: "YOUR_AUTH_DOMAIN",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_STORAGE_BUCKET",
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
  appId: "YOUR_APP_ID"
};

const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-kanban-app';

// --- Initialize Firebase ---
let app;
let db;
let auth;

try {
  app = initializeApp(firebaseConfig);
  db = getFirestore(app);
  auth = getAuth(app);
  setLogLevel('debug'); // Enable Firestore debug logging
} catch (error) {
  console.error("Error initializing Firebase:", error);
}


// --- Column Definitions ---
const COLUMNS = [
  { id: 'todo', title: 'To Do', color: 'bg-red-500' },
  { id: 'inprogress', title: 'In Progress', color: 'bg-yellow-500' },
  { id: 'done', title: 'Done', color: 'bg-green-500' },
];

// --- Confetti Component ---
const ConfettiPiece = ({ x, y, angle, speed, color }) => {
  const style = {
    position: 'absolute',
    left: `${x}px`,
    top: `${y}px`,
    width: '10px',
    height: '10px',
    backgroundColor: color,
    opacity: 0.9,
    transform: `rotate(${angle}deg)`,
    transition: 'top 1s ease-out, opacity 1s ease-out',
  };
  return <div style={style} className="rounded-full"></div>;
};

const ConfettiExplosion = ({ isActive, onComplete }) => {
  const [pieces, setPieces] = useState([]);
  const animationFrameId = useRef(null);

  useEffect(() => {
    if (isActive) {
      const newPieces = [];
      const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
      for (let i = 0; i < 100; i++) {
        newPieces.push({
          id: Math.random(),
          x: window.innerWidth / 2,
          y: window.innerHeight / 2,
          angle: Math.random() * 360,
          speed: Math.random() * 5 + 2,
          gravity: 0.1 + Math.random() * 0.1,
          color: colors[Math.floor(Math.random() * colors.length)],
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10 - 5,
        });
      }
      setPieces(newPieces);

      const animate = () => {
        setPieces(prevPieces =>
          prevPieces.map(p => ({
            ...p,
            x: p.x + p.vx,
            y: p.y + p.vy,
            vy: p.vy + p.gravity,
            angle: p.angle + p.vx * 0.1,
          })).filter(p => p.y < window.innerHeight + 50)
        );
        animationFrameId.current = requestAnimationFrame(animate);
      };
      
      animationFrameId.current = requestAnimationFrame(animate);

      const timer = setTimeout(() => {
        cancelAnimationFrame(animationFrameId.current);
        setPieces([]);
        if (onComplete) onComplete();
      }, 3000);

      return () => {
        clearTimeout(timer);
        cancelAnimationFrame(animationFrameId.current);
      };
    }
  }, [isActive, onComplete]);

  if (!isActive) return null;

  return (
    <div className="fixed inset-0 pointer-events-none z-50 overflow-hidden">
      {pieces.map(p => (
        <ConfettiPiece key={p.id} x={p.x} y={p.y} angle={p.angle} speed={p.speed} color={p.color} />
      ))}
    </div>
  );
};


// --- Task Card Component ---
const TaskCard = ({ task, onUpdateTaskStatus, onDeleteTask, onEditTask, onGenerateDescription }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editTitle, setEditTitle] = useState(task.title);
  const [editDescription, setEditDescription] = useState(task.description || '');
  const [isGeneratingDesc, setIsGeneratingDesc] = useState(false);

  const handleSaveEdit = () => {
    onEditTask(task.id, { title: editTitle, description: editDescription });
    setIsEditing(false);
  };

  const handleCancelEdit = () => {
    setEditTitle(task.title);
    setEditDescription(task.description || '');
    setIsEditing(false);
  };

  const handleGenerateDescription = async () => {
    setIsGeneratingDesc(true);
    const generatedDesc = await onGenerateDescription(task.title);
    if (generatedDesc) {
      setEditDescription(prev => prev ? `${prev}\n\n✨ AI Suggestion:\n${generatedDesc}` : `✨ AI Suggestion:\n${generatedDesc}`);
      // Automatically save the generated description
      onEditTask(task.id, { title: task.title, description: generatedDesc });
    }
    setIsGeneratingDesc(false);
  };
  
  return (
    <div className="bg-white p-4 mb-3 rounded-lg shadow-md border border-gray-200 hover:shadow-lg transition-shadow duration-200 text-gray-800">
      {isEditing ? (
        <div className="space-y-2">
          <input
            type="text"
            value={editTitle}
            onChange={(e) => setEditTitle(e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500"
            placeholder="Task Title"
          />
          <textarea
            value={editDescription}
            onChange={(e) => setEditDescription(e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 h-20"
            placeholder="Task Description (Optional)"
          />
          <div className="flex justify-end space-x-2">
            <button
              onClick={handleSaveEdit}
              className="px-3 py-1 bg-green-500 text-white rounded-md hover:bg-green-600 flex items-center text-sm"
            >
              <Save size={16} className="mr-1" /> Save
            </button>
            <button
              onClick={handleCancelEdit}
              className="px-3 py-1 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 flex items-center text-sm"
            >
              <X size={16} className="mr-1" /> Cancel
            </button>
          </div>
        </div>
      ) : (
        <>
          <h4 className="font-semibold text-gray-800 break-words">{task.title}</h4>
          {task.description ? (
            <p className="text-sm text-gray-600 mt-1 break-words whitespace-pre-wrap">{task.description}</p>
          ) : (
            <button
              onClick={handleGenerateDescription}
              disabled={isGeneratingDesc}
              className="mt-2 text-xs text-purple-600 hover:text-purple-800 flex items-center disabled:opacity-50 disabled:cursor-wait"
            >
              {isGeneratingDesc ? (
                <>
                  <Loader2 size={14} className="mr-1 animate-spin" /> Generating...
                </>
              ) : (
                <>
                  <Sparkles size={14} className="mr-1" /> ✨ Generate Description
                </>
              )}
            </button>
          )}
          <div className="mt-3 pt-3 border-t border-gray-200 flex justify-between items-center">
            <div className="flex space-x-1">
              <button
                onClick={() => setIsEditing(true)}
                className="p-1 text-gray-500 hover:text-blue-600 transition-colors"
                title="Edit Task"
              >
                <Edit3 size={16} />
              </button>
              <button
                onClick={() => onDeleteTask(task.id)}
                className="p-1 text-gray-500 hover:text-red-600 transition-colors"
                title="Delete Task"
              >
                <Trash2 size={16} />
              </button>
            </div>
            <div className="relative">
              <select
                value={task.status}
                onChange={(e) => onUpdateTaskStatus(task.id, e.target.value)}
                className="text-xs appearance-none bg-gray-100 border border-gray-300 text-gray-700 py-1 px-2 pr-6 rounded-md leading-tight focus:outline-none focus:bg-white focus:border-gray-500 hover:bg-gray-200 cursor-pointer"
              >
                {COLUMNS.map(col => (
                  <option key={col.id} value={col.id}>{col.title}</option>
                ))}
              </select>
              <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-1 text-gray-700">
                <svg className="fill-current h-3 w-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
              </div>
            </div>
          </div>
          {task.createdAt && (
            <p className="text-xs text-gray-400 mt-2">
              Created: {new Date(task.createdAt.seconds * 1000).toLocaleDateString()}
            </p>
          )}
        </>
      )}
    </div>
  );
};


// --- Main App Component ---
function App() {
  const [tasks, setTasks] = useState([]);
  const [newTaskTitle, setNewTaskTitle] = useState('');
  const [newTaskDescription, setNewTaskDescription] = useState('');
  const [showConfetti, setShowConfetti] = useState(false);
  
  const [firebaseAuth, setFirebaseAuth] = useState(null);
  const [firestoreDb, setFirestoreDb] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [error, setError] = useState(null); // For general errors
  const [geminiError, setGeminiError] = useState(null); // For Gemini API specific errors
  const [isLoading, setIsLoading] = useState(true); // For initial app load
  const [isGeminiLoading, setIsGeminiLoading] = useState(false); // For Gemini API calls
  const [showAddTaskModal, setShowAddTaskModal] = useState(false);

  // Firebase Initialization and Auth State
  useEffect(() => {
    if (!auth || !db) {
      console.error("Firebase services not available.");
      setError("Firebase services not available. Please check your configuration.");
      setIsLoading(false);
      return;
    }
    setFirebaseAuth(auth);
    setFirestoreDb(db);

    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      if (user) {
        setUserId(user.uid);
      } else {
        try {
          await setPersistence(auth, browserLocalPersistence);
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await signInWithCustomToken(auth, __initial_auth_token);
          } else {
            await signInAnonymously(auth);
          }
        } catch (authError) {
          console.error("Error during sign-in:", authError);
          setError(`Authentication failed: ${authError.message}. Tasks will not be saved.`);
        }
      }
      setIsAuthReady(true);
      setIsLoading(false);
    });
    return () => unsubscribe();
  }, []);

  // Firestore Task Subscription
  useEffect(() => {
    if (!isAuthReady || !userId || !firestoreDb) return;

    const tasksCollectionPath = `artifacts/${appId}/users/${userId}/tasks`;
    const q = query(collection(firestoreDb, tasksCollectionPath));

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
      const tasksData = [];
      querySnapshot.forEach((doc) => {
        tasksData.push({ id: doc.id, ...doc.data() });
      });
      tasksData.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
      setTasks(tasksData);
    }, (err) => {
      console.error("Error fetching tasks from Firestore:", err);
      setError(`Error fetching tasks: ${err.message}. Please try refreshing.`);
    });

    return () => unsubscribe();
  }, [isAuthReady, userId, firestoreDb]);

  // --- Gemini API Call Helper ---
  const callGeminiAPI = async (prompt) => {
    setIsGeminiLoading(true);
    setGeminiError(null);
    let text = '';
    try {
      const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
      const payload = { contents: chatHistory };
      const apiKey = ""; // Left empty as per instructions
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Gemini API Error:", errorData);
        throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      
      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        text = result.candidates[0].content.parts[0].text;
      } else {
        throw new Error("Unexpected response structure from Gemini API.");
      }
    } catch (e) {
      console.error("Error calling Gemini API:", e);
      setGeminiError(`✨ AI Helper Error: ${e.message}`);
      text = null; // Indicate failure
    } finally {
      setIsGeminiLoading(false);
    }
    return text;
  };

  const handleSuggestSubTasks = async () => {
    if (!newTaskTitle.trim()) {
      setGeminiError("Please enter a task title first to get suggestions.");
      return;
    }
    const prompt = `Break down the following task into smaller, actionable sub-tasks or a detailed description. Task Title: "${newTaskTitle}". Task Description (optional): "${newTaskDescription}". Provide the sub-tasks as a bulleted list or a concise paragraph.`;
    const suggestion = await callGeminiAPI(prompt);
    if (suggestion) {
      setNewTaskDescription(prev => prev ? `${prev}\n\n✨ Suggested Breakdown:\n${suggestion}` : `✨ Suggested Breakdown:\n${suggestion}`);
    }
  };

  const handleGenerateTaskDescriptionOnCard = async (taskTitle) => {
    const prompt = `Generate a concise and helpful description for a task titled "${taskTitle}". Focus on the key aspects or potential first steps.`;
    const description = await callGeminiAPI(prompt);
    return description; // This will be set in TaskCard and saved
  };


  const handleAddTask = async () => {
    if (!newTaskTitle.trim()) {
      setError("Task title cannot be empty.");
      return;
    }
    if (!isAuthReady || !userId || !firestoreDb) {
      setError("Cannot add task: User not authenticated or database not ready.");
      return;
    }

    const taskData = {
      title: newTaskTitle.trim(),
      description: newTaskDescription.trim(),
      status: 'todo',
      createdAt: serverTimestamp(),
      userId: userId,
    };

    try {
      const tasksCollectionPath = `artifacts/${appId}/users/${userId}/tasks`;
      await addDoc(collection(firestoreDb, tasksCollectionPath), taskData);
      setNewTaskTitle('');
      setNewTaskDescription('');
      setShowAddTaskModal(false);
      setGeminiError(null); // Clear any Gemini errors from modal
    } catch (e) {
      console.error("Error adding document: ", e);
      setError(`Error adding task: ${e.message}`);
    }
  };

  const handleUpdateTaskStatus = async (taskId, newStatus) => {
    if (!isAuthReady || !userId || !firestoreDb) {
      setError("Cannot update task: User not authenticated or database not ready.");
      return;
    }
    const taskRef = doc(firestoreDb, `artifacts/${appId}/users/${userId}/tasks`, taskId);
    try {
      await setDoc(taskRef, { status: newStatus }, { merge: true });
      if (newStatus === 'done') {
        setShowConfetti(true);
      }
    } catch (e) {
      console.error("Error updating task status: ", e);
      setError(`Error updating task: ${e.message}`);
    }
  };

  const handleEditTask = async (taskId, updatedData) => {
    if (!isAuthReady || !userId || !firestoreDb) {
      setError("Cannot edit task: User not authenticated or database not ready.");
      return;
    }
    const taskRef = doc(firestoreDb, `artifacts/${appId}/users/${userId}/tasks`, taskId);
    try {
      await setDoc(taskRef, { 
        title: updatedData.title, 
        description: updatedData.description 
      }, { merge: true });
    } catch (e) {
      console.error("Error editing task: ", e);
      setError(`Error editing task: ${e.message}`);
    }
  };


  const handleDeleteTask = async (taskId) => {
    // Using a custom modal for confirmation would be better, but window.confirm is used for simplicity here.
    // In a real app, replace this with a non-blocking UI element.
    const isConfirmed = window.confirm("Are you sure you want to delete this task?");
    if (!isConfirmed) return;


    if (!isAuthReady || !userId || !firestoreDb) {
      setError("Cannot delete task: User not authenticated or database not ready.");
      return;
    }
    const taskRef = doc(firestoreDb, `artifacts/${appId}/users/${userId}/tasks`, taskId);
    try {
      await deleteDoc(taskRef);
    } catch (e) {
      console.error("Error deleting task: ", e);
      setError(`Error deleting task: ${e.message}`);
    }
  };
  
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-500 flex items-center justify-center text-white">
        <Zap size={48} className="animate-ping mr-4" />
        <p className="text-2xl font-semibold">Loading Your Awesome Kanban Board...</p>
      </div>
    );
  }
  
  if (error && !userId && !isAuthReady) { 
    return (
      <div className="min-h-screen bg-red-100 flex flex-col items-center justify-center p-4 text-red-700">
        <h1 className="text-2xl font-bold mb-4">Initialization Error</h1>
        <p className="text-center mb-2">{error}</p>
        <p className="text-sm text-gray-600">Please ensure your Firebase configuration is correct and try refreshing the page.</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 text-white p-4 sm:p-6 md:p-8 font-sans">
      <header className="mb-8 text-center">
        <h1 className="text-4xl sm:text-5xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-purple-400 via-pink-500 to-red-500">
          Kanban Task Tracker <Bot size={36} className="inline-block ml-2 text-pink-400" />
        </h1>
        {userId && <p className="text-xs text-gray-400 mt-2">User ID: {userId}</p>}
        {error && <p className="text-sm text-red-400 mt-2 p-2 bg-red-900 bg-opacity-50 rounded-md">{error}</p>}
      </header>

      <div className="mb-6 flex justify-center">
        <button
          onClick={() => { setShowAddTaskModal(true); setGeminiError(null); /* Clear previous modal errors */ }}
          className="flex items-center bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-opacity-75"
        >
          <PlusCircle size={22} className="mr-2" /> Add New Task
        </button>
      </div>

      {showAddTaskModal && (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-40 p-4">
          <div className="bg-slate-700 p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-md">
            <h3 className="text-2xl font-semibold mb-6 text-center text-purple-300">Create a New Task</h3>
            <div className="space-y-4">
              <input
                type="text"
                placeholder="Task Title"
                value={newTaskTitle}
                onChange={(e) => setNewTaskTitle(e.target.value)}
                className="w-full p-3 bg-slate-800 text-white border border-slate-600 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none transition-colors"
              />
              <textarea
                placeholder="Task Description (Optional)"
                value={newTaskDescription}
                onChange={(e) => setNewTaskDescription(e.target.value)}
                rows="4"
                className="w-full p-3 bg-slate-800 text-white border border-slate-600 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none transition-colors h-28 resize-none"
              />
              {newTaskTitle.trim() && (
                <button
                  onClick={handleSuggestSubTasks}
                  disabled={isGeminiLoading}
                  className="w-full flex items-center justify-center text-sm py-2 px-4 bg-pink-600 hover:bg-pink-700 text-white font-medium rounded-lg transition-colors disabled:opacity-60 disabled:cursor-wait"
                >
                  {isGeminiLoading && newTaskTitle ? (
                    <>
                      <Loader2 size={18} className="mr-2 animate-spin" /> Thinking...
                    </>
                  ) : (
                    <>
                      <Sparkles size={18} className="mr-2" /> ✨ Suggest Sub-tasks
                    </>
                  )}
                </button>
              )}
              {geminiError && <p className="text-xs text-red-400 bg-red-900 bg-opacity-30 p-2 rounded-md">{geminiError}</p>}
            </div>
            <div className="mt-8 flex justify-end space-x-3">
              <button
                onClick={() => {setShowAddTaskModal(false); setGeminiError(null);}}
                className="px-5 py-2 text-sm font-medium text-gray-300 bg-slate-600 hover:bg-slate-500 rounded-lg transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleAddTask}
                disabled={!isAuthReady || !userId || isGeminiLoading}
                className="px-5 py-2 text-sm font-medium text-white bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
              >
                <PlusCircle size={18} className="mr-2" /> Add Task
              </button>
            </div>
          </div>
        </div>
      )}

      {!isAuthReady || !userId ? (
         <div className="text-center text-gray-400 p-10">
            <p>{isAuthReady ? "Authenticating..." : "Connecting to services..."}</p>
            <p className="mt-2 text-sm">Tasks will appear here once connection is established and you are signed in.</p>
         </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {COLUMNS.map(column => (
            <div key={column.id} className={`p-1 rounded-xl shadow-xl bg-slate-800`}>
              <div className={`${column.color} text-white text-lg font-semibold p-3 rounded-t-lg flex items-center justify-between`}>
                <span>{column.title}</span>
                <span className="text-sm bg-black bg-opacity-20 px-2 py-0.5 rounded-full">
                  {tasks.filter(task => task.status === column.id).length}
                </span>
              </div>
              <div className="p-4 min-h-[200px] bg-slate-800 rounded-b-lg">
                {tasks.filter(task => task.status === column.id).length === 0 && (
                  <p className="text-sm text-gray-500 text-center pt-8">No tasks here yet.</p>
                )}
                {tasks
                  .filter(task => task.status === column.id)
                  .map(task => (
                    <TaskCard
                      key={task.id}
                      task={task}
                      onUpdateTaskStatus={handleUpdateTaskStatus}
                      onDeleteTask={handleDeleteTask}
                      onEditTask={handleEditTask}
                      onGenerateDescription={handleGenerateTaskDescriptionOnCard}
                    />
                  ))}
              </div>
            </div>
          ))}
        </div>
      )}

      <ConfettiExplosion isActive={showConfetti} onComplete={() => setShowConfetti(false)} />
      
      <footer className="text-center mt-12 text-gray-500 text-sm">
        <p>Powered by React, Firebase, Tailwind CSS, and the Gemini API.</p>
        <p>App ID: {appId}</p>
      </footer>
    </div>
  );
}

export default App;
